 /*
  printf("partition 1: ");
  uint8_t u; 
  for (int i = 0; i < 15; i++) {
    u = *((uint8_t *) &b[0x01be + i]);
    printf("0x%02x, ", u);
  }
  u = *((uint8_t *) &b[0x01be + 15]);
  printf("0x%02x.\n", u);

  uint8_t p1_head = *((uint8_t *) &b[0x01be + 5]); 
  uint8_t p1_cylinder_1 = *((uint8_t *) &b[0x01be + 6]);
  uint8_t p1_cylinder_sector = *((uint8_t *) &b[0x01be + 7]);
  uint16_t p1_cylinder;

  p1_cylinder = (p1_cylinder_sector && 0xc0) << 2;
  p1_cylinder = p1_cylinder && p1_cylinder_1;
  uint8_t p1_sector = p1_cylinder_sector && 0x3f;

  printf("cylinder: 0x%02x, ", p1_cylinder);
  printf("head: 0x%02x, ", p1_head);
  printf("sector: 0x%02x.\n", p1_sector);
  */
  // LBA is a sector address.
  // CHS is also a sector address.
  // In order to convert one style of address to the other, you need to specify the drive geometry:
  // . number of cylinders  
  // . number of heads (per cylinder)  
  // . number of sectors per track
  // you cannot *translate* the geometry to an address; you use the geometry to convert an address.
  // CHS address 3,2,1 is equivalent to LBA address 3150 if the drive geometry is 1020,16,63.

  // Before LBA you simply had the physical mapping of a disk/
  // https://en.wikipedia.org/wiki/Cylinder-head-sector

  // Cylinder Number : (10b) 0-1024 (1024 = 2^10)
  // Head Number     :  (8b) 0-256  (256  = 2^8)
  // Sector Number   :  (6b) 1-64   (63   = 2^6 - 1)
  // Total CHS address : 24b (10+8+6)

  // The IBM PC/XT used a Western Digital WD1010 disk controller that used (in hardware registers) a 10-bit cylinder number.
  // The first cylinder has address 0, so there are 1024 cylinder addresses.
  
  // The first sector (of every track) is address 1, so a 6-bit sector number can address up to 63 sectors
  // (sector numbers 1 through 63) on each track.
  // There is no sector address zero. It's not reserved. It doesn't exist.
  // The subtraction of this offset is an arithmetic necessity, and is not related in any way to the boot sector. 

  // A = Logical Block Address
  // Nheads = number of heads on a disk heads-per-disk
  // Nsectors = number of sectors on a track sectors-per-track
  // c,h,s - is the cylinder,head,sector numbers 24-bits total (10+8+6)

  // A = (c * Nheads + h) * Nsectors + (s - 1)

  // e.g.
  // for geometry 1020 16 63 of a disk with 1028160 sectors CHS 3 2 1 is LBA
  // 3150 = (3 * 16 + 2) * 63 
  //
  // c 1020
  // h 16
  // s 63

  // In my work as a software/firmware engineer developing controller firmware, device drivers for disks, and filesystem handlers,
  // I never was concerned with or had to use the number of platters. The number of platters or that there are two possible surfaces
  // to a platter are mechanical properties that are totally irrelevant to the drive geometry for CHS addressing.

  // The C in CHS refers to the cylinder address. The disk drive has to (electro-mechanically) seek to the requested cylinder
  // address/location so that the R/W head assembly is positioned correctly.

  // The H in CHS refers to the R/W head address. The disk controller (electrically) selects the requested R/W head
  // (after the seek is complete) by its address to access the correct track. All other R/W heads are (electrically) disabled.

  // The S in CHS refers to the sector address. The disk controller (programmatically) scans each sector (after the seek and head selection)
  // as it rotates under the (selected) R/W head, until the requested sector is located (e.g. reads the ID record of the sector,
  // and performs an address comparison).

  // Also
  // If you're familiar with Dimensional Analysis, specifying the number of heads of a disk drive as heads per cylinder makes more sense
  // than heads per drive.

  // I understand the geometry CHS numbers, but where are the (3,2,1) tuple CHS numbers coming from?
  // That's just an arbitrary CHS address chosen for use in examples of conversions to LBA addresses.

  // BTW
  // In end-user jargon, "disk" == disk drive.
  // In professional HDD jargon, "disk" == disk platter.
  
  // The traditional limits were 512 bytes/sector × 63 sectors/track × 255 heads (tracks/cylinder) × 1024 cylinders,
  // resulting in a limit of 8032.5 MiB for the total capacity of a disk.
  
  // http://rjhcoding.com/avrc-sd-interface-1.php

  // For hard disks larger than 7,844 gigabytes, there continued to be a need to support CHS addressing for compatibility reasons,
  // at least for booting. Modern BIOSs can switch to Logical Block Addressing (LBA) mode using the Int13h interrupt extensions.
  // Using LBA, the hard disk is simply addressed as a single, large device, which simply counts the existing blocks starting at 0.
  // An LBA block thus corresponds to a sector using CHS addressing.
  // https://www.thomas-krenn.com/en/wiki/CHS_and_LBA_Hard_Disk_Addresses
  
  // https://codeandlife.com/2012/04/02/simple-fat-and-sd-tutorial-part-1/
 
 
 
/*
      for (n = 0; n < 4; n++) {                    // operation condition register
        ocr[n] = spi_rx_8();
      }
      
      if (ocr[2] == 0x01 && ocr[3] == 0xaa) {      // ACMD41 with HCS bit
        printf(", acmd41 with hcs bit");

        do {
          if (sd_send_cmd(CMD55, 0) <= 1 && sd_send_cmd(CMD41, 1UL << 30) == 0) break;
        } while (1);

        printf(", cmd55, cmd41");

	if (sd_send_cmd(CMD58, 0) == 0) {          // check CCS bit
          for (n = 0; n < 4; n++) {
            ocr[n] = spi_rx_8();
          }
          printf(", ccs bit ok, sd card ready.\n");
          type = (ocr[0] & 0x40) ? CT_SD2 | CT_BLOCK : CT_SD2; // SDv2 (HC or SC)
        }
      }
    else {                                         // SDC V1 or MMC
      type = (SD_SendCmd(CMD55, 0) <= 1 && SD_SendCmd(CMD41, 0) <= 1) ? CT_SD1 : CT_MMC;
      do {
        if (type == CT_SD1) {
          if (SD_SendCmd(CMD55, 0) <= 1 && SD_SendCmd(CMD41, 0) == 0) break; // ACMD41
        } else {
          if (SD_SendCmd(CMD1, 0) == 0) break;     // CMD1
        }
      } while (1);
      if (SD_SendCmd(CMD16, 512) != 0) type = 0;   // SET_BLOCKLEN
    }
    */
  
